package activitypub

import (
	"crypto/sha256"
	"encoding/base64"
	"encoding/json"
	"strings"
	"testing"
	"time"

	"github.com/deemkeen/stegodon/domain"
	"github.com/deemkeen/stegodon/util"
	"github.com/google/uuid"
)

func TestAcceptActivityGeneration(t *testing.T) {
	// Test the structure of Accept activity generated by SendAccept logic
	followID := "https://mastodon.social/follows/123"
	acceptID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	remoteActorURI := "https://mastodon.social/users/bob"

	accept := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       acceptID,
		"type":     "Accept",
		"actor":    actorURI,
		"object": map[string]any{
			"id":     followID,
			"type":   "Follow",
			"actor":  remoteActorURI,
			"object": actorURI,
		},
	}

	// Verify structure can be marshaled
	jsonBytes, err := json.Marshal(accept)
	if err != nil {
		t.Fatalf("Failed to marshal Accept activity: %v", err)
	}

	// Parse back to verify structure
	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Accept: %v", err)
	}

	if parsed["type"] != "Accept" {
		t.Errorf("Expected type Accept, got %v", parsed["type"])
	}
	if parsed["actor"] != actorURI {
		t.Errorf("Expected actor %s, got %v", actorURI, parsed["actor"])
	}

	// Verify embedded object
	obj := parsed["object"].(map[string]any)
	if obj["type"] != "Follow" {
		t.Error("Expected embedded object type Follow")
	}
	if obj["id"] != followID {
		t.Error("Expected embedded object to reference original Follow")
	}
}

func TestCreateActivityGeneration(t *testing.T) {
	// Test Create activity structure for notes
	noteId := uuid.New()
	createdAt := time.Now()
	actorURI := "https://stegodon.example/users/alice"
	noteURI := "https://stegodon.example/notes/" + noteId.String()
	createID := "https://stegodon.example/activities/" + uuid.New().String()

	create := map[string]any{
		"@context":  "https://www.w3.org/ns/activitystreams",
		"id":        createID,
		"type":      "Create",
		"actor":     actorURI,
		"published": createdAt.Format(time.RFC3339),
		"to": []string{
			"https://www.w3.org/ns/activitystreams#Public",
		},
		"cc": []string{
			"https://stegodon.example/users/alice/followers",
		},
		"object": map[string]any{
			"id":           noteURI,
			"type":         "Note",
			"attributedTo": actorURI,
			"content":      "Test note content",
			"published":    createdAt.Format(time.RFC3339),
			"to": []string{
				"https://www.w3.org/ns/activitystreams#Public",
			},
			"cc": []string{
				"https://stegodon.example/users/alice/followers",
			},
		},
	}

	jsonBytes, err := json.Marshal(create)
	if err != nil {
		t.Fatalf("Failed to marshal Create activity: %v", err)
	}

	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Create: %v", err)
	}

	if parsed["type"] != "Create" {
		t.Error("Expected type Create")
	}

	// Verify addressing
	to := parsed["to"].([]any)
	if len(to) != 1 || to[0] != "https://www.w3.org/ns/activitystreams#Public" {
		t.Error("Expected public addressing in to field")
	}

	cc := parsed["cc"].([]any)
	if len(cc) != 1 {
		t.Error("Expected followers in cc field")
	}

	// Verify embedded Note
	obj := parsed["object"].(map[string]any)
	if obj["type"] != "Note" {
		t.Error("Expected embedded object type Note")
	}
	if obj["content"] != "Test note content" {
		t.Error("Expected note content in object")
	}
}

func TestUpdateActivityGeneration(t *testing.T) {
	// Test Update activity structure
	noteId := uuid.New()
	createdAt := time.Now().Add(-1 * time.Hour)
	editedAt := time.Now()
	actorURI := "https://stegodon.example/users/alice"
	noteURI := "https://stegodon.example/notes/" + noteId.String()
	updateID := "https://stegodon.example/activities/" + uuid.New().String()

	update := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       updateID,
		"type":     "Update",
		"actor":    actorURI,
		"to": []string{
			"https://www.w3.org/ns/activitystreams#Public",
		},
		"cc": []string{
			"https://stegodon.example/users/alice/followers",
		},
		"object": map[string]any{
			"id":           noteURI,
			"type":         "Note",
			"attributedTo": actorURI,
			"content":      "Updated content",
			"published":    createdAt.Format(time.RFC3339),
			"updated":      editedAt.Format(time.RFC3339),
			"to": []string{
				"https://www.w3.org/ns/activitystreams#Public",
			},
			"cc": []string{
				"https://stegodon.example/users/alice/followers",
			},
		},
	}

	jsonBytes, err := json.Marshal(update)
	if err != nil {
		t.Fatalf("Failed to marshal Update activity: %v", err)
	}

	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Update: %v", err)
	}

	if parsed["type"] != "Update" {
		t.Error("Expected type Update")
	}

	obj := parsed["object"].(map[string]any)
	if obj["type"] != "Note" {
		t.Error("Expected embedded object type Note")
	}

	// Verify both published and updated timestamps
	if obj["published"] == nil {
		t.Error("Expected published timestamp")
	}
	if obj["updated"] == nil {
		t.Error("Expected updated timestamp")
	}
}

func TestDeleteActivityGeneration(t *testing.T) {
	// Test Delete activity structure
	noteId := uuid.New()
	actorURI := "https://stegodon.example/users/alice"
	noteURI := "https://stegodon.example/notes/" + noteId.String()
	deleteID := "https://stegodon.example/activities/" + uuid.New().String()

	deleteActivity := map[string]any{
		"@context":  "https://www.w3.org/ns/activitystreams",
		"id":        deleteID,
		"type":      "Delete",
		"actor":     actorURI,
		"published": time.Now().Format(time.RFC3339),
		"to": []string{
			"https://www.w3.org/ns/activitystreams#Public",
		},
		"cc": []string{
			"https://stegodon.example/users/alice/followers",
		},
		"object": noteURI,
	}

	jsonBytes, err := json.Marshal(deleteActivity)
	if err != nil {
		t.Fatalf("Failed to marshal Delete activity: %v", err)
	}

	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Delete: %v", err)
	}

	if parsed["type"] != "Delete" {
		t.Error("Expected type Delete")
	}

	// In Delete, object is just a URI string
	if parsed["object"] != noteURI {
		t.Errorf("Expected object to be URI %s", noteURI)
	}
}

func TestFollowActivityGeneration(t *testing.T) {
	// Test Follow activity structure
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	remoteActorURI := "https://mastodon.social/users/bob"

	follow := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       followID,
		"type":     "Follow",
		"actor":    actorURI,
		"object":   remoteActorURI,
	}

	jsonBytes, err := json.Marshal(follow)
	if err != nil {
		t.Fatalf("Failed to marshal Follow activity: %v", err)
	}

	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Follow: %v", err)
	}

	if parsed["type"] != "Follow" {
		t.Error("Expected type Follow")
	}
	if parsed["actor"] != actorURI {
		t.Error("Expected local actor URI")
	}
	if parsed["object"] != remoteActorURI {
		t.Error("Expected remote actor URI in object")
	}
}

func TestActivityURIGeneration(t *testing.T) {
	// Test that URIs are properly formatted
	tests := []struct {
		name     string
		domain   string
		username string
		id       string
		uriType  string
		expected string
	}{
		{
			name:     "actor URI",
			domain:   "stegodon.example",
			username: "alice",
			uriType:  "actor",
			expected: "https://stegodon.example/users/alice",
		},
		{
			name:     "activity URI",
			domain:   "stegodon.example",
			id:       uuid.New().String(),
			uriType:  "activity",
			expected: "https://stegodon.example/activities/",
		},
		{
			name:     "note URI",
			domain:   "stegodon.example",
			id:       uuid.New().String(),
			uriType:  "note",
			expected: "https://stegodon.example/notes/",
		},
		{
			name:     "followers URI",
			domain:   "stegodon.example",
			username: "alice",
			uriType:  "followers",
			expected: "https://stegodon.example/users/alice/followers",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			var uri string
			switch tt.uriType {
			case "actor":
				uri = "https://" + tt.domain + "/users/" + tt.username
			case "activity":
				uri = "https://" + tt.domain + "/activities/" + tt.id
			case "note":
				uri = "https://" + tt.domain + "/notes/" + tt.id
			case "followers":
				uri = "https://" + tt.domain + "/users/" + tt.username + "/followers"
			}

			if !strings.HasPrefix(uri, "https://") {
				t.Error("URI should use HTTPS")
			}
			if !strings.Contains(uri, tt.domain) {
				t.Error("URI should contain domain")
			}
			if tt.username != "" && !strings.Contains(uri, tt.username) {
				t.Error("URI should contain username")
			}
			if tt.expected != "" && !strings.HasPrefix(uri, tt.expected) {
				t.Errorf("Expected URI to start with %s, got %s", tt.expected, uri)
			}
		})
	}
}

func TestActivityAddressing(t *testing.T) {
	// Test public addressing patterns
	publicURI := "https://www.w3.org/ns/activitystreams#Public"
	followersURI := "https://stegodon.example/users/alice/followers"

	// Test addressing arrays
	to := []string{publicURI}
	cc := []string{followersURI}

	if len(to) != 1 || to[0] != publicURI {
		t.Error("Expected public URI in 'to' field")
	}
	if len(cc) != 1 || cc[0] != followersURI {
		t.Error("Expected followers URI in 'cc' field")
	}

	// Verify JSON serialization
	addressing := map[string]any{
		"to": to,
		"cc": cc,
	}

	jsonBytes, _ := json.Marshal(addressing)
	var parsed map[string]any
	json.Unmarshal(jsonBytes, &parsed)

	parsedTo := parsed["to"].([]any)
	if parsedTo[0] != publicURI {
		t.Error("Public URI should be preserved in JSON")
	}
}

func TestMustMarshal(t *testing.T) {
	// Test mustMarshal helper function
	tests := []struct {
		name  string
		input any
		want  string
	}{
		{
			name:  "simple string",
			input: "hello",
			want:  `"hello"`,
		},
		{
			name:  "map",
			input: map[string]string{"type": "Follow"},
			want:  `{"type":"Follow"}`,
		},
		{
			name:  "array",
			input: []string{"a", "b"},
			want:  `["a","b"]`,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			result := mustMarshal(tt.input)
			if result != tt.want {
				t.Errorf("Expected %s, got %s", tt.want, result)
			}
		})
	}
}

func TestMustMarshalPanic(t *testing.T) {
	// Test that mustMarshal panics on error (e.g., channels cannot be marshaled)
	defer func() {
		if r := recover(); r == nil {
			t.Error("Expected mustMarshal to panic on unmarshallable type")
		}
	}()

	ch := make(chan int)
	mustMarshal(ch) // Should panic
}

func TestActivityTimestamps(t *testing.T) {
	// Test RFC3339 timestamp formatting
	now := time.Now()
	formatted := now.Format(time.RFC3339)

	// Verify format is correct
	if !strings.Contains(formatted, "T") {
		t.Error("RFC3339 should contain T separator")
	}
	if !strings.Contains(formatted, ":") {
		t.Error("RFC3339 should contain time separators")
	}

	// Parse back to verify
	parsed, err := time.Parse(time.RFC3339, formatted)
	if err != nil {
		t.Fatalf("Failed to parse RFC3339 timestamp: %v", err)
	}

	// Times should be equal within a second
	if parsed.Sub(now) > time.Second || now.Sub(parsed) > time.Second {
		t.Error("Timestamp parsing should preserve time accurately")
	}
}

func TestDeliveryQueueItemCreation(t *testing.T) {
	// Test creating delivery queue items
	inboxURI := "https://mastodon.social/inbox"
	activity := map[string]string{"type": "Create"}
	activityJSON := mustMarshal(activity)

	queueItem := &domain.DeliveryQueueItem{
		Id:           uuid.New(),
		InboxURI:     inboxURI,
		ActivityJSON: activityJSON,
		Attempts:     0,
		NextRetryAt:  time.Now(),
		CreatedAt:    time.Now(),
	}

	if queueItem.InboxURI != inboxURI {
		t.Error("InboxURI should be set correctly")
	}
	if queueItem.Attempts != 0 {
		t.Error("New queue items should start with 0 attempts")
	}
	if queueItem.ActivityJSON != activityJSON {
		t.Error("Activity JSON should be stored")
	}

	// Verify activity can be unmarshaled
	var parsedActivity map[string]string
	if err := json.Unmarshal([]byte(queueItem.ActivityJSON), &parsedActivity); err != nil {
		t.Error("Stored activity JSON should be valid")
	}
	if parsedActivity["type"] != "Create" {
		t.Error("Activity should be preserved in queue")
	}
}

func TestHTTPHeaders(t *testing.T) {
	// Test that we set proper headers for ActivityPub
	contentType := "application/activity+json"
	accept := "application/activity+json"
	userAgent := "stegodon/1.0 ActivityPub"

	if contentType != "application/activity+json" {
		t.Error("Content-Type should be application/activity+json")
	}
	if accept != "application/activity+json" {
		t.Error("Accept should be application/activity+json")
	}
	if !strings.Contains(userAgent, "stegodon") {
		t.Error("User-Agent should identify as stegodon")
	}
}

func TestDigestCalculation(t *testing.T) {
	// Test digest header calculation for HTTP signatures
	activityJSON := []byte(`{"type":"Follow"}`)

	// This is what SendActivity does
	hash := sha256.Sum256(activityJSON)
	digest := "SHA-256=" + base64.StdEncoding.EncodeToString(hash[:])

	if !strings.HasPrefix(digest, "SHA-256=") {
		t.Error("Digest should have SHA-256= prefix")
	}
	if len(digest) < 50 {
		t.Error("Digest should contain base64 encoded hash")
	}

	// Verify the same input produces same digest
	hash2 := sha256.Sum256(activityJSON)
	digest2 := "SHA-256=" + base64.StdEncoding.EncodeToString(hash2[:])
	if digest != digest2 {
		t.Error("Same input should produce same digest")
	}
}

func TestKeyIDFormat(t *testing.T) {
	// Test key ID formatting for HTTP signatures
	domain := "stegodon.example"
	username := "alice"
	keyID := "https://" + domain + "/users/" + username + "#main-key"

	if !strings.HasPrefix(keyID, "https://") {
		t.Error("Key ID should use HTTPS")
	}
	if !strings.Contains(keyID, username) {
		t.Error("Key ID should contain username")
	}
	if !strings.HasSuffix(keyID, "#main-key") {
		t.Error("Key ID should end with #main-key")
	}

	expectedFormat := "https://stegodon.example/users/alice#main-key"
	if keyID != expectedFormat {
		t.Errorf("Expected key ID %s, got %s", expectedFormat, keyID)
	}
}

func TestPublicURIConstant(t *testing.T) {
	// Test the public addressing constant
	publicURI := "https://www.w3.org/ns/activitystreams#Public"

	if !strings.HasPrefix(publicURI, "https://") {
		t.Error("Public URI should use HTTPS")
	}
	if !strings.Contains(publicURI, "activitystreams") {
		t.Error("Public URI should reference ActivityStreams")
	}
	if !strings.HasSuffix(publicURI, "#Public") {
		t.Error("Public URI should end with #Public")
	}
}

func TestContextURI(t *testing.T) {
	// Test ActivityStreams context URI
	contextURI := "https://www.w3.org/ns/activitystreams"

	if !strings.HasPrefix(contextURI, "https://") {
		t.Error("Context URI should use HTTPS")
	}
	if !strings.Contains(contextURI, "w3.org") {
		t.Error("Context should be from W3C")
	}
}

// Tests for Undo activity (unfollow)

func TestUndoActivityGeneration(t *testing.T) {
	// Test Undo activity structure for unfollowing
	undoID := "https://stegodon.example/activities/" + uuid.New().String()
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	remoteActorURI := "https://mastodon.social/users/bob"

	undo := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       undoID,
		"type":     "Undo",
		"actor":    actorURI,
		"object": map[string]any{
			"id":     followID,
			"type":   "Follow",
			"actor":  actorURI,
			"object": remoteActorURI,
		},
	}

	// Verify structure can be marshaled
	jsonBytes, err := json.Marshal(undo)
	if err != nil {
		t.Fatalf("Failed to marshal Undo activity: %v", err)
	}

	// Parse back to verify structure
	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Undo: %v", err)
	}

	if parsed["type"] != "Undo" {
		t.Errorf("Expected type Undo, got %v", parsed["type"])
	}
	if parsed["actor"] != actorURI {
		t.Errorf("Expected actor %s, got %v", actorURI, parsed["actor"])
	}

	// Verify embedded Follow object
	obj := parsed["object"].(map[string]any)
	if obj["type"] != "Follow" {
		t.Error("Expected embedded object type Follow")
	}
	if obj["id"] != followID {
		t.Error("Expected embedded object to reference original Follow")
	}
	if obj["actor"] != actorURI {
		t.Error("Expected Follow actor to match Undo actor")
	}
	if obj["object"] != remoteActorURI {
		t.Error("Expected Follow object to be remote actor URI")
	}
}

func TestUndoActivityStructureValidation(t *testing.T) {
	// Test that Undo activity follows ActivityPub specification
	// https://www.w3.org/TR/activitypub/#undo-activity
	undoID := "https://stegodon.example/activities/" + uuid.New().String()
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	remoteActorURI := "https://mastodon.social/users/bob"

	undo := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       undoID,
		"type":     "Undo",
		"actor":    actorURI,
		"object": map[string]any{
			"id":     followID,
			"type":   "Follow",
			"actor":  actorURI,
			"object": remoteActorURI,
		},
	}

	jsonBytes, err := json.Marshal(undo)
	if err != nil {
		t.Fatalf("Failed to marshal Undo activity: %v", err)
	}

	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal Undo: %v", err)
	}

	// Required fields
	if parsed["@context"] == nil {
		t.Error("Undo activity must have @context")
	}
	if parsed["id"] == nil {
		t.Error("Undo activity must have id")
	}
	if parsed["type"] != "Undo" {
		t.Error("Undo activity must have type 'Undo'")
	}
	if parsed["actor"] == nil {
		t.Error("Undo activity must have actor")
	}
	if parsed["object"] == nil {
		t.Error("Undo activity must have object")
	}

	// Object must be a Follow activity (for unfollow)
	obj := parsed["object"].(map[string]any)
	if obj["type"] != "Follow" {
		t.Error("For unfollow, Undo object must be a Follow activity")
	}

	// The Follow's actor should match the Undo's actor
	if obj["actor"] != parsed["actor"] {
		t.Error("Follow actor should match Undo actor")
	}
}

func TestUndoFollowWorkflow(t *testing.T) {
	// Test the complete unfollow workflow structure
	// 1. Original Follow was sent
	// 2. Now sending Undo to cancel it

	// Original Follow
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	targetURI := "https://mastodon.social/users/bob"

	originalFollow := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       followID,
		"type":     "Follow",
		"actor":    actorURI,
		"object":   targetURI,
	}

	// Verify original Follow is valid
	followJSON, err := json.Marshal(originalFollow)
	if err != nil {
		t.Fatalf("Failed to marshal Follow: %v", err)
	}

	var parsedFollow map[string]any
	if err := json.Unmarshal(followJSON, &parsedFollow); err != nil {
		t.Fatalf("Failed to parse Follow: %v", err)
	}

	// Now create Undo that references this Follow
	undoID := "https://stegodon.example/activities/" + uuid.New().String()
	undo := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       undoID,
		"type":     "Undo",
		"actor":    actorURI,
		"object":   originalFollow, // Embed the entire Follow
	}

	undoJSON, err := json.Marshal(undo)
	if err != nil {
		t.Fatalf("Failed to marshal Undo: %v", err)
	}

	var parsedUndo map[string]any
	if err := json.Unmarshal(undoJSON, &parsedUndo); err != nil {
		t.Fatalf("Failed to parse Undo: %v", err)
	}

	// Verify the embedded Follow is intact
	embeddedFollow := parsedUndo["object"].(map[string]any)
	if embeddedFollow["id"] != followID {
		t.Error("Embedded Follow should retain original ID")
	}
	if embeddedFollow["type"] != "Follow" {
		t.Error("Embedded object should be Follow")
	}
	if embeddedFollow["actor"] != actorURI {
		t.Error("Embedded Follow should have same actor as Undo")
	}
}

func TestUndoActivityComparison(t *testing.T) {
	// Compare Undo structure with other activities to ensure consistency
	actorURI := "https://stegodon.example/users/alice"
	targetURI := "https://mastodon.social/users/bob"

	// Follow activity
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	follow := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       followID,
		"type":     "Follow",
		"actor":    actorURI,
		"object":   targetURI,
	}

	// Undo activity
	undoID := "https://stegodon.example/activities/" + uuid.New().String()
	undo := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       undoID,
		"type":     "Undo",
		"actor":    actorURI,
		"object":   follow,
	}

	// Both should have required fields
	for _, activity := range []map[string]any{follow, undo} {
		if activity["@context"] == nil {
			t.Error("All activities must have @context")
		}
		if activity["id"] == nil {
			t.Error("All activities must have id")
		}
		if activity["type"] == nil {
			t.Error("All activities must have type")
		}
		if activity["actor"] == nil {
			t.Error("All activities must have actor")
		}
		if activity["object"] == nil {
			t.Error("All activities must have object")
		}
	}

	// IDs should be unique
	if follow["id"] == undo["id"] {
		t.Error("Follow and Undo should have different IDs")
	}

	// Actors should be the same (same person unfollowing)
	if follow["actor"] != undo["actor"] {
		t.Error("Follow and Undo should have same actor for unfollow")
	}
}

func TestUndoJSONMarshaling(t *testing.T) {
	// Test that Undo activity can be marshaled and unmarshaled without data loss
	undoID := "https://stegodon.example/activities/" + uuid.New().String()
	followID := "https://stegodon.example/activities/" + uuid.New().String()
	actorURI := "https://stegodon.example/users/alice"
	targetURI := "https://mastodon.social/users/bob"

	original := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       undoID,
		"type":     "Undo",
		"actor":    actorURI,
		"object": map[string]any{
			"id":     followID,
			"type":   "Follow",
			"actor":  actorURI,
			"object": targetURI,
		},
	}

	// Marshal
	jsonBytes, err := json.Marshal(original)
	if err != nil {
		t.Fatalf("Failed to marshal: %v", err)
	}

	// Unmarshal
	var parsed map[string]any
	if err := json.Unmarshal(jsonBytes, &parsed); err != nil {
		t.Fatalf("Failed to unmarshal: %v", err)
	}

	// Verify all fields preserved
	if parsed["id"] != original["id"] {
		t.Error("ID should be preserved")
	}
	if parsed["type"] != original["type"] {
		t.Error("Type should be preserved")
	}
	if parsed["actor"] != original["actor"] {
		t.Error("Actor should be preserved")
	}

	// Verify nested object preserved
	originalObj := original["object"].(map[string]any)
	parsedObj := parsed["object"].(map[string]any)

	if parsedObj["id"] != originalObj["id"] {
		t.Error("Nested Follow ID should be preserved")
	}
	if parsedObj["type"] != originalObj["type"] {
		t.Error("Nested Follow type should be preserved")
	}
	if parsedObj["actor"] != originalObj["actor"] {
		t.Error("Nested Follow actor should be preserved")
	}
	if parsedObj["object"] != originalObj["object"] {
		t.Error("Nested Follow object should be preserved")
	}
}

// Tests for self-follow prevention

func TestSelfFollowDetection(t *testing.T) {
	// Test detection of self-follow attempt (same domain and username)
	sslDomain := "stegodon.example"
	username := "alice"

	localAccount := &domain.Account{
		Id:       uuid.New(),
		Username: username,
	}

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: username,
		Domain:   sslDomain,
		ActorURI: "https://" + sslDomain + "/users/" + username,
	}

	// Check if this is a self-follow attempt
	isSelfFollow := (remoteActor.Domain == sslDomain && remoteActor.Username == localAccount.Username)

	if !isSelfFollow {
		t.Error("Should detect self-follow when domain and username match")
	}
}

func TestSelfFollowDetectionDifferentUser(t *testing.T) {
	// Test that different users on same domain are not detected as self-follow
	sslDomain := "stegodon.example"

	localAccount := &domain.Account{
		Id:       uuid.New(),
		Username: "alice",
	}

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "bob", // Different user
		Domain:   sslDomain,
		ActorURI: "https://" + sslDomain + "/users/bob",
	}

	// Check if this is a self-follow attempt
	isSelfFollow := (remoteActor.Domain == sslDomain && remoteActor.Username == localAccount.Username)

	if isSelfFollow {
		t.Error("Should NOT detect self-follow when usernames differ")
	}
}

func TestSelfFollowDetectionDifferentDomain(t *testing.T) {
	// Test that same username on different domain is not detected as self-follow
	localAccount := &domain.Account{
		Id:       uuid.New(),
		Username: "alice",
	}

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "alice",           // Same username
		Domain:   "mastodon.social", // Different domain
		ActorURI: "https://mastodon.social/users/alice",
	}

	localDomain := "stegodon.example"

	// Check if this is a self-follow attempt
	isSelfFollow := (remoteActor.Domain == localDomain && remoteActor.Username == localAccount.Username)

	if isSelfFollow {
		t.Error("Should NOT detect self-follow when domains differ")
	}
}

func TestSelfFollowErrorMessage(t *testing.T) {
	// Test that self-follow error message is user-friendly
	errMsg := "self-follow not allowed on stegodon for now"

	if !strings.Contains(strings.ToLower(errMsg), "self-follow") {
		t.Error("Error message should mention 'self-follow'")
	}

	if !strings.Contains(strings.ToLower(errMsg), "not allowed") {
		t.Error("Error message should indicate it's not allowed")
	}

	if !strings.Contains(strings.ToLower(errMsg), "stegodon") {
		t.Error("Error message should mention stegodon")
	}

	// Should not be too technical
	if strings.Contains(errMsg, "error") || strings.Contains(errMsg, "failed") {
		t.Error("Error message should be user-friendly, not technical")
	}
}

func TestSelfFollowPreventionTiming(t *testing.T) {
	// Test that self-follow check happens early (before database operations)
	// This is important to avoid unnecessary database writes

	// In the actual SendFollow function, the check order is:
	// 1. Fetch remote actor (GetOrFetchActor)
	// 2. Check if self-follow â† THIS SHOULD HAPPEN HERE
	// 3. Check if already following (database read)
	// 4. Create follow record (database write)

	// The self-follow check should happen at step 2, before any database operations
	// This test verifies the logic is correct

	sslDomain := "stegodon.example"
	username := "alice"

	localAccount := &domain.Account{
		Id:       uuid.New(),
		Username: username,
	}

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: username,
		Domain:   sslDomain,
		ActorURI: "https://" + sslDomain + "/users/" + username,
	}

	// Check self-follow BEFORE any other operations
	isSelfFollow := (remoteActor.Domain == sslDomain && remoteActor.Username == localAccount.Username)

	if !isSelfFollow {
		t.Fatal("Failed to detect self-follow at early stage")
	}

	// If we get here, we would return early and NOT proceed with:
	// - Database read for existing follow
	// - Database write for new follow
	// This is the desired behavior
}

func TestSelfFollowCaseSensitivity(t *testing.T) {
	// Test that username comparison is case-sensitive (ActivityPub standard)
	sslDomain := "stegodon.example"

	tests := []struct {
		name           string
		localUsername  string
		remoteUsername string
		shouldMatch    bool
	}{
		{
			name:           "Exact match",
			localUsername:  "alice",
			remoteUsername: "alice",
			shouldMatch:    true,
		},
		{
			name:           "Different case",
			localUsername:  "alice",
			remoteUsername: "Alice",
			shouldMatch:    false, // ActivityPub usernames are case-sensitive
		},
		{
			name:           "All uppercase",
			localUsername:  "alice",
			remoteUsername: "ALICE",
			shouldMatch:    false,
		},
		{
			name:           "Different users",
			localUsername:  "alice",
			remoteUsername: "bob",
			shouldMatch:    false,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			localAccount := &domain.Account{
				Id:       uuid.New(),
				Username: tt.localUsername,
			}

			remoteActor := &domain.RemoteAccount{
				Id:       uuid.New(),
				Username: tt.remoteUsername,
				Domain:   sslDomain,
				ActorURI: "https://" + sslDomain + "/users/" + tt.remoteUsername,
			}

			isSelfFollow := (remoteActor.Domain == sslDomain && remoteActor.Username == localAccount.Username)

			if isSelfFollow != tt.shouldMatch {
				t.Errorf("Expected isSelfFollow=%v for local=%s remote=%s, got %v",
					tt.shouldMatch, tt.localUsername, tt.remoteUsername, isSelfFollow)
			}
		})
	}
}

func TestSelfFollowDomainComparison(t *testing.T) {
	// Test that domain comparison works correctly
	tests := []struct {
		name         string
		localDomain  string
		remoteDomain string
		shouldMatch  bool
	}{
		{
			name:         "Same domain",
			localDomain:  "stegodon.example",
			remoteDomain: "stegodon.example",
			shouldMatch:  true,
		},
		{
			name:         "Different domains",
			localDomain:  "stegodon.example",
			remoteDomain: "mastodon.social",
			shouldMatch:  false,
		},
		{
			name:         "Subdomain difference",
			localDomain:  "stegodon.example.com",
			remoteDomain: "mastodon.example.com",
			shouldMatch:  false,
		},
		{
			name:         "Port in domain",
			localDomain:  "stegodon.example:3000",
			remoteDomain: "stegodon.example",
			shouldMatch:  false, // Should be exact match
		},
	}

	username := "alice"

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			localAccount := &domain.Account{
				Id:       uuid.New(),
				Username: username,
			}

			remoteActor := &domain.RemoteAccount{
				Id:       uuid.New(),
				Username: username,
				Domain:   tt.remoteDomain,
				ActorURI: "https://" + tt.remoteDomain + "/users/" + username,
			}

			isSelfFollow := (remoteActor.Domain == tt.localDomain && remoteActor.Username == localAccount.Username)

			if isSelfFollow != tt.shouldMatch {
				t.Errorf("Expected isSelfFollow=%v for local=%s remote=%s, got %v",
					tt.shouldMatch, tt.localDomain, tt.remoteDomain, isSelfFollow)
			}
		})
	}
}

// TestSendFollow_PendingFollowDetection tests that SendFollow correctly distinguishes
// between accepted and pending follow requests
func TestSendFollow_PendingFollowDetection(t *testing.T) {
	tests := []struct {
		name           string
		followAccepted bool
		expectedError  string
	}{
		{
			name:           "accepted follow returns already following",
			followAccepted: true,
			expectedError:  "already following",
		},
		{
			name:           "pending follow returns follow pending",
			followAccepted: false,
			expectedError:  "follow pending",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			// This test verifies the error message logic
			// The actual SendFollow function would check existingFollow.Accepted
			var followAccepted = tt.followAccepted
			var errMsg string

			if followAccepted {
				errMsg = "already following user@example.com"
			} else {
				errMsg = "follow pending user@example.com"
			}

			if !strings.Contains(errMsg, tt.expectedError) {
				t.Errorf("Expected error to contain '%s', got '%s'", tt.expectedError, errMsg)
			}
		})
	}
}

// ============================================================================
// Integration tests using dependency injection
// These tests use mock HTTP client and mock database
// ============================================================================

// TestSendActivityWithDeps_Success tests sending activity successfully
func TestSendActivityWithDeps_Success(t *testing.T) {
	mockHTTP := NewMockHTTPClient()

	// Create test account with keypair
	keypair, err := GenerateTestKeyPair()
	if err != nil {
		t.Fatalf("Failed to generate test keypair: %v", err)
	}

	account := CreateTestAccount("alice", keypair)

	// Set up successful response from remote inbox
	inboxURI := "https://remote.example.com/inbox"
	mockHTTP.SetResponse(inboxURI, 202, []byte("Accepted"))

	// Create test config
	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	// Create test activity
	activity := map[string]any{
		"@context": "https://www.w3.org/ns/activitystreams",
		"id":       "https://local.example.com/activities/123",
		"type":     "Follow",
		"actor":    "https://local.example.com/users/alice",
		"object":   "https://remote.example.com/users/bob",
	}

	// Send the activity
	err = SendActivityWithDeps(activity, inboxURI, account, conf, mockHTTP)
	if err != nil {
		t.Fatalf("SendActivityWithDeps failed: %v", err)
	}

	// Verify HTTP request was made
	if len(mockHTTP.Requests) != 1 {
		t.Errorf("Expected 1 HTTP request, got %d", len(mockHTTP.Requests))
	}

	// Verify request properties
	req := mockHTTP.Requests[0]
	if req.Method != "POST" {
		t.Errorf("Expected POST method, got %s", req.Method)
	}
	if req.URL.String() != inboxURI {
		t.Errorf("Expected URL %s, got %s", inboxURI, req.URL.String())
	}
	if req.Header.Get("Content-Type") != "application/activity+json" {
		t.Error("Expected Content-Type: application/activity+json")
	}
	if req.Header.Get("Signature") == "" {
		t.Error("Expected Signature header")
	}
	if req.Header.Get("Digest") == "" {
		t.Error("Expected Digest header")
	}
}

// TestSendActivityWithDeps_RemoteError tests handling of remote server errors
func TestSendActivityWithDeps_RemoteError(t *testing.T) {
	mockHTTP := NewMockHTTPClient()

	keypair, err := GenerateTestKeyPair()
	if err != nil {
		t.Fatalf("Failed to generate test keypair: %v", err)
	}

	account := CreateTestAccount("alice", keypair)
	inboxURI := "https://remote.example.com/inbox"

	// Set up error response
	mockHTTP.SetResponse(inboxURI, 500, []byte("Internal Server Error"))

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	activity := map[string]any{
		"type": "Follow",
	}

	err = SendActivityWithDeps(activity, inboxURI, account, conf, mockHTTP)
	if err == nil {
		t.Error("Expected error for 500 response")
	}
	if !strings.Contains(err.Error(), "500") {
		t.Errorf("Error should mention status code: %v", err)
	}
}

// TestSendActivityWithDeps_NetworkError tests handling of network errors
func TestSendActivityWithDeps_NetworkError(t *testing.T) {
	mockHTTP := NewMockHTTPClient()

	keypair, err := GenerateTestKeyPair()
	if err != nil {
		t.Fatalf("Failed to generate test keypair: %v", err)
	}

	account := CreateTestAccount("alice", keypair)
	inboxURI := "https://remote.example.com/inbox"

	// Set up network error
	mockHTTP.SetError(inboxURI, &mockNetworkError{message: "connection refused"})

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	activity := map[string]any{
		"type": "Follow",
	}

	err = SendActivityWithDeps(activity, inboxURI, account, conf, mockHTTP)
	if err == nil {
		t.Error("Expected error for network failure")
	}
	if !strings.Contains(err.Error(), "request failed") {
		t.Errorf("Error should mention request failure: %v", err)
	}
}

// TestSendAcceptWithDeps tests sending Accept activity
func TestSendAcceptWithDeps_Success(t *testing.T) {
	mockHTTP := NewMockHTTPClient()

	keypair, err := GenerateTestKeyPair()
	if err != nil {
		t.Fatalf("Failed to generate test keypair: %v", err)
	}

	account := CreateTestAccount("alice", keypair)

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "bob",
		Domain:   "remote.example.com",
		ActorURI: "https://remote.example.com/users/bob",
		InboxURI: "https://remote.example.com/users/bob/inbox",
	}

	followID := "https://remote.example.com/follows/123"

	// Set up successful response
	mockHTTP.SetResponse(remoteActor.InboxURI, 202, []byte("Accepted"))

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	err = SendAcceptWithDeps(account, remoteActor, followID, conf, mockHTTP)
	if err != nil {
		t.Fatalf("SendAcceptWithDeps failed: %v", err)
	}

	// Verify HTTP request was made
	if len(mockHTTP.Requests) != 1 {
		t.Errorf("Expected 1 HTTP request, got %d", len(mockHTTP.Requests))
	}

	// Verify request body contains Accept activity
	req := mockHTTP.Requests[0]
	if req.Method != "POST" {
		t.Errorf("Expected POST method, got %s", req.Method)
	}
}

// TestSendFollowWithDeps_NewFollow tests sending a new follow request
func TestSendFollowWithDeps_NewFollow(t *testing.T) {
	mockDB := NewMockDatabase()
	mockHTTP := NewMockHTTPClient()

	keypair, err := GenerateTestKeyPair()
	if err != nil {
		t.Fatalf("Failed to generate test keypair: %v", err)
	}

	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	// Set up remote actor response
	remoteActorURI := "https://remote.example.com/users/bob"
	actorResponse := ActorResponse{
		ID:                remoteActorURI,
		Type:              "Person",
		PreferredUsername: "bob",
		Name:              "Bob",
		Inbox:             "https://remote.example.com/users/bob/inbox",
	}
	actorResponse.PublicKey.PublicKeyPem = "-----BEGIN PUBLIC KEY-----\ntest\n-----END PUBLIC KEY-----"

	err = mockHTTP.SetJSONResponse(remoteActorURI, 200, actorResponse)
	if err != nil {
		t.Fatalf("Failed to set mock response: %v", err)
	}

	// Set up successful inbox response
	mockHTTP.SetResponse("https://remote.example.com/users/bob/inbox", 202, []byte("Accepted"))

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	err = SendFollowWithDeps(account, remoteActorURI, conf, mockHTTP, mockDB)
	if err != nil {
		t.Fatalf("SendFollowWithDeps failed: %v", err)
	}

	// Verify follow was stored in database
	if len(mockDB.Follows) != 1 {
		t.Errorf("Expected 1 follow record, got %d", len(mockDB.Follows))
	}

	// Verify follow is pending (not accepted)
	for _, follow := range mockDB.Follows {
		if follow.Accepted {
			t.Error("New follow should be pending, not accepted")
		}
	}

	// Verify 2 HTTP requests: actor fetch + inbox POST
	if len(mockHTTP.Requests) != 2 {
		t.Errorf("Expected 2 HTTP requests, got %d", len(mockHTTP.Requests))
	}
}

// TestSendFollowWithDeps_SelfFollow tests self-follow prevention
func TestSendFollowWithDeps_SelfFollow(t *testing.T) {
	mockDB := NewMockDatabase()
	mockHTTP := NewMockHTTPClient()

	keypair, err := GenerateTestKeyPair()
	if err != nil {
		t.Fatalf("Failed to generate test keypair: %v", err)
	}

	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	// Set up remote actor that matches local user
	remoteActorURI := "https://local.example.com/users/alice"
	actorResponse := ActorResponse{
		ID:                remoteActorURI,
		Type:              "Person",
		PreferredUsername: "alice",
		Name:              "Alice",
		Inbox:             "https://local.example.com/users/alice/inbox",
	}
	actorResponse.PublicKey.PublicKeyPem = "-----BEGIN PUBLIC KEY-----\ntest\n-----END PUBLIC KEY-----"

	err = mockHTTP.SetJSONResponse(remoteActorURI, 200, actorResponse)
	if err != nil {
		t.Fatalf("Failed to set mock response: %v", err)
	}

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	err = SendFollowWithDeps(account, remoteActorURI, conf, mockHTTP, mockDB)
	if err == nil {
		t.Error("Expected error for self-follow")
	}
	if !strings.Contains(err.Error(), "self-follow") {
		t.Errorf("Error should mention self-follow: %v", err)
	}

	// Verify no follow was stored
	if len(mockDB.Follows) != 0 {
		t.Error("Self-follow should not create follow record")
	}
}

// TestSendFollowWithDeps_AlreadyFollowing tests duplicate follow prevention
func TestSendFollowWithDeps_AlreadyFollowing(t *testing.T) {
	mockDB := NewMockDatabase()
	mockHTTP := NewMockHTTPClient()

	keypair, err := GenerateTestKeyPair()
	if err != nil {
		t.Fatalf("Failed to generate test keypair: %v", err)
	}

	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	// Set up remote actor
	remoteActorURI := "https://remote.example.com/users/bob"
	remoteActor := &domain.RemoteAccount{
		Id:            uuid.New(),
		Username:      "bob",
		Domain:        "remote.example.com",
		ActorURI:      remoteActorURI,
		InboxURI:      "https://remote.example.com/users/bob/inbox",
		PublicKeyPem:  "test-key",
		LastFetchedAt: time.Now(),
	}
	mockDB.AddRemoteAccount(remoteActor)

	// Add existing accepted follow
	existingFollow := &domain.Follow{
		Id:              uuid.New(),
		AccountId:       account.Id,
		TargetAccountId: remoteActor.Id,
		URI:             "https://local.example.com/follows/123",
		Accepted:        true,
		CreatedAt:       time.Now(),
	}
	mockDB.AddFollow(existingFollow)

	actorResponse := ActorResponse{
		ID:                remoteActorURI,
		Type:              "Person",
		PreferredUsername: "bob",
		Name:              "Bob",
		Inbox:             "https://remote.example.com/users/bob/inbox",
	}
	actorResponse.PublicKey.PublicKeyPem = "test-key"

	err = mockHTTP.SetJSONResponse(remoteActorURI, 200, actorResponse)
	if err != nil {
		t.Fatalf("Failed to set mock response: %v", err)
	}

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	err = SendFollowWithDeps(account, remoteActorURI, conf, mockHTTP, mockDB)
	if err == nil {
		t.Error("Expected error for already following")
	}
	if !strings.Contains(err.Error(), "already following") {
		t.Errorf("Error should mention already following: %v", err)
	}
}

// TestSendFollowWithDeps_PendingFollow tests pending follow detection
func TestSendFollowWithDeps_PendingFollow(t *testing.T) {
	mockDB := NewMockDatabase()
	mockHTTP := NewMockHTTPClient()

	keypair, err := GenerateTestKeyPair()
	if err != nil {
		t.Fatalf("Failed to generate test keypair: %v", err)
	}

	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	// Set up remote actor
	remoteActorURI := "https://remote.example.com/users/bob"
	remoteActor := &domain.RemoteAccount{
		Id:            uuid.New(),
		Username:      "bob",
		Domain:        "remote.example.com",
		ActorURI:      remoteActorURI,
		InboxURI:      "https://remote.example.com/users/bob/inbox",
		PublicKeyPem:  "test-key",
		LastFetchedAt: time.Now(),
	}
	mockDB.AddRemoteAccount(remoteActor)

	// Add existing pending follow
	existingFollow := &domain.Follow{
		Id:              uuid.New(),
		AccountId:       account.Id,
		TargetAccountId: remoteActor.Id,
		URI:             "https://local.example.com/follows/123",
		Accepted:        false, // Pending
		CreatedAt:       time.Now(),
	}
	mockDB.AddFollow(existingFollow)

	actorResponse := ActorResponse{
		ID:                remoteActorURI,
		Type:              "Person",
		PreferredUsername: "bob",
		Name:              "Bob",
		Inbox:             "https://remote.example.com/users/bob/inbox",
	}
	actorResponse.PublicKey.PublicKeyPem = "test-key"

	err = mockHTTP.SetJSONResponse(remoteActorURI, 200, actorResponse)
	if err != nil {
		t.Fatalf("Failed to set mock response: %v", err)
	}

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	err = SendFollowWithDeps(account, remoteActorURI, conf, mockHTTP, mockDB)
	if err == nil {
		t.Error("Expected error for pending follow")
	}
	if !strings.Contains(err.Error(), "follow pending") {
		t.Errorf("Error should mention pending follow: %v", err)
	}
}

// TestSendUndoWithDeps tests sending Undo (unfollow) activity
func TestSendUndoWithDeps_Success(t *testing.T) {
	mockHTTP := NewMockHTTPClient()

	keypair, err := GenerateTestKeyPair()
	if err != nil {
		t.Fatalf("Failed to generate test keypair: %v", err)
	}

	account := CreateTestAccount("alice", keypair)

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "bob",
		Domain:   "remote.example.com",
		ActorURI: "https://remote.example.com/users/bob",
		InboxURI: "https://remote.example.com/users/bob/inbox",
	}

	follow := &domain.Follow{
		Id:              uuid.New(),
		AccountId:       account.Id,
		TargetAccountId: remoteActor.Id,
		URI:             "https://local.example.com/follows/123",
		Accepted:        true,
		CreatedAt:       time.Now(),
	}

	// Set up successful response
	mockHTTP.SetResponse(remoteActor.InboxURI, 202, []byte("Accepted"))

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	err = SendUndoWithDeps(account, follow, remoteActor, conf, mockHTTP)
	if err != nil {
		t.Fatalf("SendUndoWithDeps failed: %v", err)
	}

	// Verify HTTP request was made
	if len(mockHTTP.Requests) != 1 {
		t.Errorf("Expected 1 HTTP request, got %d", len(mockHTTP.Requests))
	}
}

// mockNetworkError is a mock network error for testing (if not already defined)
type mockOutboxNetworkError struct {
	message string
}

func (e *mockOutboxNetworkError) Error() string {
	return e.message
}

// ============================================================================
// Tests for SendCreate, SendUpdate, SendDelete with dependency injection
// ============================================================================

// TestSendCreateWithDeps_NoFollowers tests creating a note with no followers
func TestSendCreateWithDeps_NoFollowers(t *testing.T) {
	mockDB := NewMockDatabase()

	keypair, _ := GenerateTestKeyPair()
	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	// No followers added to mock DB

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	note := &domain.Note{
		Id:        uuid.New(),
		CreatedBy: account.Username,
		Message:   "Hello, world!",
		CreatedAt: time.Now(),
	}

	err := SendCreateWithDeps(note, account, conf, mockDB)
	if err != nil {
		t.Errorf("SendCreateWithDeps should not fail with no followers: %v", err)
	}

	// Verify no delivery items were queued
	if len(mockDB.DeliveryQueue) != 0 {
		t.Errorf("Expected 0 delivery queue items, got %d", len(mockDB.DeliveryQueue))
	}
}

// TestSendCreateWithDeps_WithFollowers tests creating a note that gets delivered to followers
func TestSendCreateWithDeps_WithFollowers(t *testing.T) {
	mockDB := NewMockDatabase()

	keypair, _ := GenerateTestKeyPair()
	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	// Add two remote followers
	remoteActor1 := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "bob",
		Domain:   "remote1.example.com",
		ActorURI: "https://remote1.example.com/users/bob",
		InboxURI: "https://remote1.example.com/users/bob/inbox",
	}
	mockDB.AddRemoteAccount(remoteActor1)

	remoteActor2 := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "carol",
		Domain:   "remote2.example.com",
		ActorURI: "https://remote2.example.com/users/carol",
		InboxURI: "https://remote2.example.com/users/carol/inbox",
	}
	mockDB.AddRemoteAccount(remoteActor2)

	// Add follow relationships (remote actors following local account)
	follow1 := &domain.Follow{
		Id:              uuid.New(),
		AccountId:       remoteActor1.Id,
		TargetAccountId: account.Id,
		URI:             "https://remote1.example.com/follows/1",
		Accepted:        true,
		CreatedAt:       time.Now(),
	}
	mockDB.AddFollow(follow1)

	follow2 := &domain.Follow{
		Id:              uuid.New(),
		AccountId:       remoteActor2.Id,
		TargetAccountId: account.Id,
		URI:             "https://remote2.example.com/follows/2",
		Accepted:        true,
		CreatedAt:       time.Now(),
	}
	mockDB.AddFollow(follow2)

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	note := &domain.Note{
		Id:        uuid.New(),
		CreatedBy: account.Username,
		Message:   "Hello, followers!",
		CreatedAt: time.Now(),
	}

	err := SendCreateWithDeps(note, account, conf, mockDB)
	if err != nil {
		t.Errorf("SendCreateWithDeps failed: %v", err)
	}

	// Verify delivery items were queued for each follower
	if len(mockDB.DeliveryQueue) != 2 {
		t.Errorf("Expected 2 delivery queue items, got %d", len(mockDB.DeliveryQueue))
	}

	// Verify delivery queue contents
	inboxURIs := make(map[string]bool)
	for _, item := range mockDB.DeliveryQueue {
		inboxURIs[item.InboxURI] = true

		// Verify activity JSON contains expected fields
		var activity map[string]any
		if err := json.Unmarshal([]byte(item.ActivityJSON), &activity); err != nil {
			t.Errorf("Failed to parse activity JSON: %v", err)
			continue
		}

		if activity["type"] != "Create" {
			t.Errorf("Expected activity type 'Create', got %v", activity["type"])
		}

		obj, ok := activity["object"].(map[string]any)
		if !ok {
			t.Error("Expected object to be a map")
			continue
		}

		if obj["type"] != "Note" {
			t.Errorf("Expected object type 'Note', got %v", obj["type"])
		}

		if obj["content"] != "Hello, followers!" {
			t.Errorf("Expected content 'Hello, followers!', got %v", obj["content"])
		}
	}

	if !inboxURIs["https://remote1.example.com/users/bob/inbox"] {
		t.Error("Expected delivery to remote1")
	}
	if !inboxURIs["https://remote2.example.com/users/carol/inbox"] {
		t.Error("Expected delivery to remote2")
	}
}

// TestSendUpdateWithDeps_NoFollowers tests updating a note with no followers
func TestSendUpdateWithDeps_NoFollowers(t *testing.T) {
	mockDB := NewMockDatabase()

	keypair, _ := GenerateTestKeyPair()
	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	editedAt := time.Now()
	note := &domain.Note{
		Id:        uuid.New(),
		CreatedBy: account.Username,
		Message:   "Updated message",
		CreatedAt: time.Now().Add(-1 * time.Hour),
		EditedAt:  &editedAt,
	}

	err := SendUpdateWithDeps(note, account, conf, mockDB)
	if err != nil {
		t.Errorf("SendUpdateWithDeps should not fail with no followers: %v", err)
	}

	if len(mockDB.DeliveryQueue) != 0 {
		t.Errorf("Expected 0 delivery queue items, got %d", len(mockDB.DeliveryQueue))
	}
}

// TestSendUpdateWithDeps_WithFollowers tests updating a note that gets delivered to followers
func TestSendUpdateWithDeps_WithFollowers(t *testing.T) {
	mockDB := NewMockDatabase()

	keypair, _ := GenerateTestKeyPair()
	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	// Add one follower
	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "bob",
		Domain:   "remote.example.com",
		ActorURI: "https://remote.example.com/users/bob",
		InboxURI: "https://remote.example.com/users/bob/inbox",
	}
	mockDB.AddRemoteAccount(remoteActor)

	follow := &domain.Follow{
		Id:              uuid.New(),
		AccountId:       remoteActor.Id,
		TargetAccountId: account.Id,
		URI:             "https://remote.example.com/follows/1",
		Accepted:        true,
		CreatedAt:       time.Now(),
	}
	mockDB.AddFollow(follow)

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	editedAt := time.Now()
	note := &domain.Note{
		Id:        uuid.New(),
		CreatedBy: account.Username,
		Message:   "Updated content",
		CreatedAt: time.Now().Add(-1 * time.Hour),
		EditedAt:  &editedAt,
	}

	err := SendUpdateWithDeps(note, account, conf, mockDB)
	if err != nil {
		t.Errorf("SendUpdateWithDeps failed: %v", err)
	}

	// Verify delivery item was queued
	if len(mockDB.DeliveryQueue) != 1 {
		t.Fatalf("Expected 1 delivery queue item, got %d", len(mockDB.DeliveryQueue))
	}

	// Verify activity is Update type
	for _, item := range mockDB.DeliveryQueue {
		var activity map[string]any
		if err := json.Unmarshal([]byte(item.ActivityJSON), &activity); err != nil {
			t.Errorf("Failed to parse activity JSON: %v", err)
			continue
		}

		if activity["type"] != "Update" {
			t.Errorf("Expected activity type 'Update', got %v", activity["type"])
		}

		obj, ok := activity["object"].(map[string]any)
		if !ok {
			t.Error("Expected object to be a map")
			continue
		}

		if obj["updated"] == nil {
			t.Error("Expected 'updated' timestamp in object")
		}
	}
}

// TestSendUpdateWithDeps_NoEditedAt tests Update with nil EditedAt (uses CreatedAt)
func TestSendUpdateWithDeps_NoEditedAt(t *testing.T) {
	mockDB := NewMockDatabase()

	keypair, _ := GenerateTestKeyPair()
	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "bob",
		Domain:   "remote.example.com",
		ActorURI: "https://remote.example.com/users/bob",
		InboxURI: "https://remote.example.com/users/bob/inbox",
	}
	mockDB.AddRemoteAccount(remoteActor)

	follow := &domain.Follow{
		Id:              uuid.New(),
		AccountId:       remoteActor.Id,
		TargetAccountId: account.Id,
		URI:             "https://remote.example.com/follows/1",
		Accepted:        true,
		CreatedAt:       time.Now(),
	}
	mockDB.AddFollow(follow)

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	createdAt := time.Now().Add(-1 * time.Hour)
	note := &domain.Note{
		Id:        uuid.New(),
		CreatedBy: account.Username,
		Message:   "Content without edit timestamp",
		CreatedAt: createdAt,
		EditedAt:  nil, // No edit timestamp
	}

	err := SendUpdateWithDeps(note, account, conf, mockDB)
	if err != nil {
		t.Errorf("SendUpdateWithDeps failed: %v", err)
	}

	// Verify activity uses CreatedAt for updated timestamp
	for _, item := range mockDB.DeliveryQueue {
		var activity map[string]any
		if err := json.Unmarshal([]byte(item.ActivityJSON), &activity); err != nil {
			t.Errorf("Failed to parse activity JSON: %v", err)
			continue
		}

		obj := activity["object"].(map[string]any)
		if obj["updated"] != createdAt.Format(time.RFC3339) {
			t.Errorf("Expected 'updated' to equal CreatedAt when EditedAt is nil")
		}
	}
}

// TestSendDeleteWithDeps_NoFollowers tests deleting a note with no followers
func TestSendDeleteWithDeps_NoFollowers(t *testing.T) {
	mockDB := NewMockDatabase()

	keypair, _ := GenerateTestKeyPair()
	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	noteId := uuid.New()

	err := SendDeleteWithDeps(noteId, account, conf, mockDB)
	if err != nil {
		t.Errorf("SendDeleteWithDeps should not fail with no followers: %v", err)
	}

	if len(mockDB.DeliveryQueue) != 0 {
		t.Errorf("Expected 0 delivery queue items, got %d", len(mockDB.DeliveryQueue))
	}
}

// TestSendDeleteWithDeps_WithFollowers tests deleting a note that gets delivered to followers
func TestSendDeleteWithDeps_WithFollowers(t *testing.T) {
	mockDB := NewMockDatabase()

	keypair, _ := GenerateTestKeyPair()
	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	// Add follower
	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "bob",
		Domain:   "remote.example.com",
		ActorURI: "https://remote.example.com/users/bob",
		InboxURI: "https://remote.example.com/users/bob/inbox",
	}
	mockDB.AddRemoteAccount(remoteActor)

	follow := &domain.Follow{
		Id:              uuid.New(),
		AccountId:       remoteActor.Id,
		TargetAccountId: account.Id,
		URI:             "https://remote.example.com/follows/1",
		Accepted:        true,
		CreatedAt:       time.Now(),
	}
	mockDB.AddFollow(follow)

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	noteId := uuid.New()

	err := SendDeleteWithDeps(noteId, account, conf, mockDB)
	if err != nil {
		t.Errorf("SendDeleteWithDeps failed: %v", err)
	}

	// Verify delivery item was queued
	if len(mockDB.DeliveryQueue) != 1 {
		t.Fatalf("Expected 1 delivery queue item, got %d", len(mockDB.DeliveryQueue))
	}

	// Verify activity is Delete type
	for _, item := range mockDB.DeliveryQueue {
		var activity map[string]any
		if err := json.Unmarshal([]byte(item.ActivityJSON), &activity); err != nil {
			t.Errorf("Failed to parse activity JSON: %v", err)
			continue
		}

		if activity["type"] != "Delete" {
			t.Errorf("Expected activity type 'Delete', got %v", activity["type"])
		}

		// For Delete, object is a URI string
		objStr, ok := activity["object"].(string)
		if !ok {
			t.Error("Expected object to be a string URI for Delete activity")
			continue
		}

		expectedNoteURI := "https://local.example.com/notes/" + noteId.String()
		if objStr != expectedNoteURI {
			t.Errorf("Expected object URI %s, got %s", expectedNoteURI, objStr)
		}
	}
}

// TestSendCreateWithDeps_MarkdownConversion tests that markdown links are converted to HTML
func TestSendCreateWithDeps_MarkdownConversion(t *testing.T) {
	mockDB := NewMockDatabase()

	keypair, _ := GenerateTestKeyPair()
	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "bob",
		Domain:   "remote.example.com",
		ActorURI: "https://remote.example.com/users/bob",
		InboxURI: "https://remote.example.com/users/bob/inbox",
	}
	mockDB.AddRemoteAccount(remoteActor)

	follow := &domain.Follow{
		Id:              uuid.New(),
		AccountId:       remoteActor.Id,
		TargetAccountId: account.Id,
		URI:             "https://remote.example.com/follows/1",
		Accepted:        true,
		CreatedAt:       time.Now(),
	}
	mockDB.AddFollow(follow)

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	note := &domain.Note{
		Id:        uuid.New(),
		CreatedBy: account.Username,
		Message:   "Check out [this link](https://example.com)!",
		CreatedAt: time.Now(),
	}

	err := SendCreateWithDeps(note, account, conf, mockDB)
	if err != nil {
		t.Errorf("SendCreateWithDeps failed: %v", err)
	}

	// Verify content was converted to HTML
	for _, item := range mockDB.DeliveryQueue {
		var activity map[string]any
		if err := json.Unmarshal([]byte(item.ActivityJSON), &activity); err != nil {
			t.Errorf("Failed to parse activity JSON: %v", err)
			continue
		}

		obj := activity["object"].(map[string]any)
		content := obj["content"].(string)

		// Should contain HTML anchor tag
		if !strings.Contains(content, "<a href=") {
			t.Errorf("Expected markdown link to be converted to HTML, got: %s", content)
		}

		if obj["mediaType"] != "text/html" {
			t.Errorf("Expected mediaType 'text/html', got %v", obj["mediaType"])
		}
	}
}

// TestSendCreateWithDeps_Hashtags tests that hashtags are included in the tag array
func TestSendCreateWithDeps_Hashtags(t *testing.T) {
	mockDB := NewMockDatabase()

	keypair, _ := GenerateTestKeyPair()
	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "bob",
		Domain:   "remote.example.com",
		ActorURI: "https://remote.example.com/users/bob",
		InboxURI: "https://remote.example.com/users/bob/inbox",
	}
	mockDB.AddRemoteAccount(remoteActor)

	follow := &domain.Follow{
		Id:              uuid.New(),
		AccountId:       remoteActor.Id,
		TargetAccountId: account.Id,
		URI:             "https://remote.example.com/follows/1",
		Accepted:        true,
		CreatedAt:       time.Now(),
	}
	mockDB.AddFollow(follow)

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	note := &domain.Note{
		Id:        uuid.New(),
		CreatedBy: account.Username,
		Message:   "Hello #golang and #fediverse!",
		CreatedAt: time.Now(),
	}

	err := SendCreateWithDeps(note, account, conf, mockDB)
	if err != nil {
		t.Errorf("SendCreateWithDeps failed: %v", err)
	}

	// Verify hashtags are in the tag array
	for _, item := range mockDB.DeliveryQueue {
		var activity map[string]any
		if err := json.Unmarshal([]byte(item.ActivityJSON), &activity); err != nil {
			t.Errorf("Failed to parse activity JSON: %v", err)
			continue
		}

		// Verify @context includes Hashtag definition
		context, ok := activity["@context"].([]any)
		if !ok {
			t.Error("Expected @context to be an array when hashtags are present")
			continue
		}
		if len(context) < 2 {
			t.Errorf("Expected @context to have at least 2 elements, got %d", len(context))
		}
		// Check that the second element contains Hashtag definition
		if contextMap, ok := context[1].(map[string]any); ok {
			if contextMap["Hashtag"] != "as:Hashtag" {
				t.Errorf("Expected Hashtag definition in context, got %v", contextMap["Hashtag"])
			}
		} else {
			t.Error("Expected second context element to be a map with Hashtag definition")
		}

		obj := activity["object"].(map[string]any)
		tags, ok := obj["tag"].([]any)
		if !ok {
			t.Error("Expected 'tag' array in object")
			continue
		}

		if len(tags) != 2 {
			t.Errorf("Expected 2 hashtags in tag array, got %d", len(tags))
		}

		// Verify hashtag structure
		hashtagNames := make(map[string]bool)
		for _, tag := range tags {
			tagMap := tag.(map[string]any)
			if tagMap["type"] != "Hashtag" {
				t.Errorf("Expected tag type 'Hashtag', got %v", tagMap["type"])
			}
			name := tagMap["name"].(string)
			hashtagNames[name] = true

			// Verify href format
			href := tagMap["href"].(string)
			if !strings.HasPrefix(href, "https://local.example.com/tags/") {
				t.Errorf("Expected href to start with https://local.example.com/tags/, got %s", href)
			}
		}

		if !hashtagNames["#golang"] {
			t.Error("Expected '#golang' in hashtags")
		}
		if !hashtagNames["#fediverse"] {
			t.Error("Expected '#fediverse' in hashtags")
		}
	}
}

// TestSendCreateWithDeps_NoHashtags tests that notes without hashtags don't have tag array
func TestSendCreateWithDeps_NoHashtags(t *testing.T) {
	mockDB := NewMockDatabase()

	keypair, _ := GenerateTestKeyPair()
	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "bob",
		Domain:   "remote.example.com",
		ActorURI: "https://remote.example.com/users/bob",
		InboxURI: "https://remote.example.com/users/bob/inbox",
	}
	mockDB.AddRemoteAccount(remoteActor)

	follow := &domain.Follow{
		Id:              uuid.New(),
		AccountId:       remoteActor.Id,
		TargetAccountId: account.Id,
		URI:             "https://remote.example.com/follows/1",
		Accepted:        true,
		CreatedAt:       time.Now(),
	}
	mockDB.AddFollow(follow)

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	note := &domain.Note{
		Id:        uuid.New(),
		CreatedBy: account.Username,
		Message:   "Hello world, no hashtags here!",
		CreatedAt: time.Now(),
	}

	err := SendCreateWithDeps(note, account, conf, mockDB)
	if err != nil {
		t.Errorf("SendCreateWithDeps failed: %v", err)
	}

	// Verify no tag array in the object and context is simple string
	for _, item := range mockDB.DeliveryQueue {
		var activity map[string]any
		if err := json.Unmarshal([]byte(item.ActivityJSON), &activity); err != nil {
			t.Errorf("Failed to parse activity JSON: %v", err)
			continue
		}

		// Verify @context is a simple string (not array) when no hashtags
		context, ok := activity["@context"].(string)
		if !ok {
			t.Error("Expected @context to be a simple string when no hashtags are present")
		} else if context != "https://www.w3.org/ns/activitystreams" {
			t.Errorf("Expected @context to be ActivityStreams URL, got %s", context)
		}

		obj := activity["object"].(map[string]any)
		if _, ok := obj["tag"]; ok {
			t.Error("Expected no 'tag' array for note without hashtags")
		}
	}
}

// TestSendUpdateWithDeps_Hashtags tests that Update activity includes hashtags
func TestSendUpdateWithDeps_Hashtags(t *testing.T) {
	mockDB := NewMockDatabase()

	keypair, _ := GenerateTestKeyPair()
	account := CreateTestAccount("alice", keypair)
	mockDB.AddAccount(account)

	remoteActor := &domain.RemoteAccount{
		Id:       uuid.New(),
		Username: "bob",
		Domain:   "remote.example.com",
		ActorURI: "https://remote.example.com/users/bob",
		InboxURI: "https://remote.example.com/users/bob/inbox",
	}
	mockDB.AddRemoteAccount(remoteActor)

	follow := &domain.Follow{
		Id:              uuid.New(),
		AccountId:       remoteActor.Id,
		TargetAccountId: account.Id,
		URI:             "https://remote.example.com/follows/1",
		Accepted:        true,
		CreatedAt:       time.Now(),
	}
	mockDB.AddFollow(follow)

	conf := &util.AppConfig{}
	conf.Conf.SslDomain = "local.example.com"

	editedAt := time.Now()
	note := &domain.Note{
		Id:        uuid.New(),
		CreatedBy: account.Username,
		Message:   "Updated with #rust and #activitypub",
		CreatedAt: time.Now().Add(-1 * time.Hour),
		EditedAt:  &editedAt,
	}

	err := SendUpdateWithDeps(note, account, conf, mockDB)
	if err != nil {
		t.Errorf("SendUpdateWithDeps failed: %v", err)
	}

	// Verify hashtags are in the tag array
	for _, item := range mockDB.DeliveryQueue {
		var activity map[string]any
		if err := json.Unmarshal([]byte(item.ActivityJSON), &activity); err != nil {
			t.Errorf("Failed to parse activity JSON: %v", err)
			continue
		}

		if activity["type"] != "Update" {
			t.Errorf("Expected activity type 'Update', got %v", activity["type"])
		}

		obj := activity["object"].(map[string]any)
		tags, ok := obj["tag"].([]any)
		if !ok {
			t.Error("Expected 'tag' array in object for Update activity")
			continue
		}

		if len(tags) != 2 {
			t.Errorf("Expected 2 hashtags in tag array, got %d", len(tags))
		}
	}
}
